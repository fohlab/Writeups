# Stack1 Challenge


**Important note:** This writeup assumes that you already have a basic understanding of how the stack and function calling works in assembly.

First we need to get the source code of the vulnerable application. You can find it <a href="https://exploit-exercises.lains.space/protostar/stack1/">here</a>.


```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  if(argc == 1) {
      errx(1, "please specify an argument\n");
  }

  modified = 0;
  strcpy(buffer, argv[1]);

  if(modified == 0x61626364) {
      printf("you have correctly got the variable to the right value\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }
}
```

Let's examine the above code.

Firstly, there is a `volatile int modified` variable and a charachter buffer with **64** bytes. Then there is a check if we provided an argument and the `modified` variable is set to **0**. The `strcpy` function will copy the contents of the provided argument to the buffer and next there is a check `if(modified == 0x61626364)`. That is where the **volatile** part of the first variable comes into play. This variable was first set to **0**, never changed and then tested if it is equal to **0x61626364**. The compiler sees that the variable will never be equal to that value and will omit it and the if statement completely if we did not specify the variable as **volatile**.

If `modified == 0x616263641` is true then we have succeded. So it seems our goal is to somehow change the value of that variable, but how can that be?

Let's compile the source code to a working executable with `gcc stack1.c -o stack1 -fno-stack-protector` . 

You can learn more about `-fno-stack-protector` option <a href="https://stackoverflow.com/questions/2340259/how-to-turn-off-gcc-compiler-optimization-to-enable-buffer-overflow">here</a>

Confirm behaviour:

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack1/images/behaviour.png">  

We see that providing the wrong argument we fail.

Since we already have the source code and know the behaviour of the program, we will keep things simple and jump straight to **GEF** . GEF (GDB Enhanced features) as the name is suggests a wrapper over the classic GNU debugger and provides many more features. You can learn more and install it at <a href="https://github.com/hugsy/gef">GEF Github</a>.

Move to the path of the executable and start the debugger with `gdb -q stack1`. The `-q` option is not necessary and just omits some info about gdb when it starts.

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack1/images/gef_start.png">

Now let's disassemble the main function with `disas main`.  

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack1/images/disas_main.png">

The first few lines is standard assembly code when a function is called (in this case main) and we will talk about it another time. At **main+8** ( 0x0x00000000000011b1) we see `sub rsp,0x60` . As we know the stack grows downward and substracting 0x60 from the stack pointer aims to make space for the variables that are going to be stored there.

Three commands later we see a **compare**  and then a **jump if not equal** command `cmp DWORD PTR [rbp-0x54],0x1`,   
`jne 0x11d8 <main+47>`. 

The second command will jump somewhere in the program if the compared values of the previous instruction are not equal. But what is actually compared here? 

The command compares the value stored at the address **rbp-0x54** with **1**. Looking at the previous commands we see that the value of register **edi** is moved into that address. 

Now based on the source code, we conclude that **edi** and consequently the value at **rbp-0x54** is actually the value of **argc** (argument count) in the **C** code. That is why it is compared to **1**. If we did provide an argument then **argc** would be equal to **2** and the jump would be **taken**!

```c
if(argc == 1) {
      errx(1, "please specify an argument\n"); # Corresponding code
  }
  ```

If **argc** is loaded at **rbp-0x54** then what is loaded at **rbp-0x60** ? 
As you may have guessed that is **argv**.

Up next at **main+47** we see the value **0** being loaded at location **rbp-0x4**. This is actually the **modified** variable being loaded in the stack.

Afterwards we see **argv** being loaded in **rax**, we add **8** bytes to it to get to **argv[1]** where our argument is located and in the end the value of the argument is loaded in **rdx** with `mov rdx,QWORD PTR [rax]`.    

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack1/images/load_argv1.png">  

At last, we see  

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack1/images/cmp.png">

The first three commands basically prepare the system for the `strcpy` call. Here `lea rax,[rbp-0x50]` tells us that our buffer will probably begin at **rbp-0x50**.

Then **strcpy** is called, the contents of address **rbp-0x4** (remember this is where our variable resides) is loaded to the **eax** register. In the end there is a compare, corresponding to the `if(modified == 0x61626364)` part of the code.

How can this condition be true if the variable was set to **0** ?

Well, we know that our variable is stored in the stack at **rbp-0x4** while our buffer starts at **rbp-0x50** so they probably live right next to each other. What if we provide an argument that is larger than what can be stored in our buffer ? We calculate **0x50 - 0x4 = 76** ,so let's provide an input that is **77** charachters long.

An easy way to do this is to use python. Open a terminal and write

```python
python -c "print('A' * 77)" # python3
```
This will give us 77 A's to work with.

Now into **gef** let's insert a break point just before the final `cmp` at `main+83` with `break *main+83`. Then run the application with the input we got above. The breakpoint will halt the application just before the `cmp` command is executed.

Type `run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack1/images/eax1.png">

We see program flow was stopped right before the compare, and I also run the command `info register eax` to see the contents of that register at the given time. As you can see, by giving an input of **77** bytes we managed to overwrite the first byte of **eax** with **\x41** which is just the Hex code for **A**. **Success!**.

Now all we have to do is overwrite eax with **0x61626364** or in ascii **abcd**. BUT! remember that Intel processors are **Little-Endian**, which means we will actually have to write **dcba** !.

Again using python

```python
import struct
value = struct.pack("<L".0x61626364)  # <L means Little-Endian Format
print("A" * 76 + value)
```

This will give us AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdcba

Run again with the above input and confirm that **eax** has been overwritten correctly.

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack1/images/eax2.png">

**And we have succeded! eax now contains 0x61626364**

Type `c` in gef to continue execution normally and you should get the desired output.

Confirm behaviour:

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack1/images/end.png">

**Perfect.** 

### Useful links

[1]. https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/


