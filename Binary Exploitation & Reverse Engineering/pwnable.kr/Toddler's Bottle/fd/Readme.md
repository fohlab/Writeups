# fd 

This is the first challenge located at <a href="http://pwnable.kr/play.php">pwnable.kr</a>.

First let's follow the instructions and connect to the remote server via ssh with `ssh -p 2222 fd@pwnable.kr `

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/pwnable.kr/Toddler's%20Bottle/fd/images/first.png">

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/pwnable.kr/Toddler's%20Bottle/fd/images/second.png>

We can immediately see three files **fd** **fd.c** and **flag**. We also notice we don't even have read privileges on **flag** so trying to solve this challenge just by `cat flag` probably won't work :)

For easier testing we will copy the files in our machine with `scp`.

Run `scp -P 2222 fd@pwnable.kr:fd.c .` and `scp -P 2222 fd@pwnable.kr:fd` to retrieve the files.
We can't do the same for the flag since we can't read it.

Let's see the source code for **fd** with `cat fd.c`. I added some comments.

```c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
char buf[32];
int main(int argc, char* argv[], char* envp[]){
	if(argc<2){                                 // Check if we provided an argument
		printf("pass argv[1] a number\n");
		return 0;
	}
	int fd = atoi( argv[1] ) - 0x1234;          // Ascii-to-integer function for our argument and then substarct 0x1234
	int len = 0;
	len = read(fd, buf, 32);                    // read() reads 32 bytes from fd and puts it into buf.
	if(!strcmp("LETMEWIN\n", buf)){             // We see that if we get buf to the value of LETMEWIN we will get the flag.
		printf("good job :)\n");
		system("/bin/cat flag");
		exit(0);
	}
	printf("learn about Linux file IO\n");
	return 0;

}
```

As you can see in the error message, it is advised to get some familiarity with Linux IO.

If fd is just a number how can we read **LETMEWIN** from it and then put it into **buf** ?

You can/should read more about **read()** <a href="http://man7.org/linux/man-pages/man2/read.2.html">here</a>

As you probably saw from the above link the first argument of read is actually a file descriptor. What this means is that it takes a certain amount of bytes from a file we opened and prints it inside **buf**.

But we have no files open!

You see, in Linux there are some very special numbers.

**0** represents **stdin** (Standard Input)
**1** represents **stdout** (Standard output)
**2** represents **stderr** (Standard Error)

These numbers are handled as file descriptors and you can read more about it <a href="https://www.howtogeek.com/435903/what-are-stdin-stdout-and-stderr-on-linux/">here</a>.

So what happens if we get the value of `fd` to **0** ? 

Before the call to `read()` 0x1234 is substracted from **fd** so we have to find the appropriate value to enter as argument for **fd** to be 0.

In decimal **0x1234** is **4660** so let's try that in the remote server.

<img src="https://github.com/astasinos/Writeups/blob/master/Binary%20Exploitation%20%26%20Reverse%20Engineering/pwnable.kr/Toddler's%20Bottle/fd/images/third.png">

Perfect! Now our program expects to read from **stdin** and we can type our input!

Let's type **LETMEWIN** (the `\n` is added when you press enter).

<!-- remote success blur it -->

### Success!
